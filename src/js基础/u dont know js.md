# 第一章
# 第二章 词法作用域
## 作用域的2种工作模型
- 词法作用域：被大多数变成语言所采用
- 动态作用域：Bash脚本、Perl

## 词法阶段
- 词法化（Tokenize）
- 词法作用域就是定义在词法阶段的作用域：
	- 由你在写代码时将变量和块作用域写在哪里来决定，词法分析器处理代码时会保持作用域不变
- 查找
	- 作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见第一个匹配的标识符为止。
	
## 在运行时“修改”词法作用域
- eval
	- 可以对一段包含一个或多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域(在运行时)
- with
	- 通过将一个对象的引用当作作用域来处理，将对象的属性当作作 用域中的标识符来处理，从而创建了一个新的词法作用域(同样是在运行时)
- 这两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认为这样的优化是无效的。使用这其中任何一个机制都将导致代码运行变慢。

# 第三章
## 函数声明和函数表达式
```
	function foo() {} 
	(function foo(){ ... })()
```
- 区别在于它们的名称标识符将会绑定在何处:
	
	- 第一个片段中 foo 被绑定在所在作用域中，可以在外部直接通过foo() 来调用它 
	- 第二个片段中 (function foo(){ .. })作为函数表达式意味着foo只能在..所代表的位置中被访问，外部作用域则不行
	
## 具名和匿名
```
 	setTimeout( function() {
         console.log("I waited 1 second!");
	}, 1000 );
```
setTimeoutl里面的函数叫作匿名函数表达式，因为 function().. 没有名称标识符。函数表达式可以是匿名的，而函数声明则不可以省略函数名——在 JavaScript 的语法中这是非法的。

- 匿名函数缺点
	- 在栈追踪中不会显示出有意义的函数名，使得调试很困难。
	- 引用自身时，只能使用已经过期的arguments.callee引用，比如在递归中。其次，事件触发后事件监听器需要解绑自身。
	- 可读性
## 块作用域
块作用域是一个用来对之前的最小授权原则进行扩展的工具。将代码从在函数中隐藏信息扩展为在块中隐藏信息。

- try/catch的作用域（ES3）
	- ES3 规范中规定 try/catch 的 catch 分句会创建一个块作fr49用域，其中声明的变量仅在 catch 内部有效。
## let 
	- let 关键字可以将变量绑定到所在的任意作用域中(通常是{...} 内部)
	- let的声明不会提升：
	使用 let 进行的声明不会在块作用域中进行提升。声明的代码被运行之前，声明并不“存在”。
```
{
	console.log( bar ); // ReferenceError! 
	let bar = 2;
}
```
	- 垃圾收集
	- let循环

# 第三章